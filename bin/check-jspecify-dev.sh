#!/usr/bin/env bash

# Purpose:
#   Run the experimental JSpecify reference checker (NullSpecChecker) over all
#   Maven modules in this repository that contain a src/main/java tree.
#
# Caching Strategy:
#   To make repeated local runs fast, the jspecify-reference-checker git clone
#   and its built artifacts are cached in an XDG cache directory (persisting
#   across script invocations):
#       ${XDG_CACHE_HOME:-$HOME/.cache}/coremedia-gcc/jspecify
#   Use --clear-cache to force a fresh clone & rebuild. If you need to update
#   to a newer upstream revision without clearing unrelated build output, just
#   remove the clone manually or run the clear option.
#
# Notes:
#   * The jspecify-reference-checker is a proof-of-concept and must be built locally.
#   * Only Java 17 is supported by the checker at the moment; this is enforced.
#   * Output is streamed to stdout; redirect to capture a report.
#
# Usage:
#   bin/check-jspecify-dev.sh [--project-root <path>] [--clear-cache]
#
# Examples:
#   bin/check-jspecify-dev.sh > jspecify-report.txt
#   bin/check-jspecify-dev.sh --project-root /path/to/checkout
#   bin/check-jspecify-dev.sh --clear-cache
#
# Exit Codes:
#   0 - All modules processed (individual checker warnings may still appear)
#   1 - Usage / argument error
#   2 - Missing dependency
#   3 - Java version unsupported
#   4 - Build failure of jspecify-reference-checker
#   5 - No Java source modules found
#
# Script initially generated by GitHub Copilot (GPT-5) and later adapted to
# persistent XDG cache usage.

declare -ri DEBUG=${DEBUG:-0}

set -o errexit
set -o nounset
set -o pipefail

### Call with `DEBUG=2 <command>.sh <file>` to enable verbose debug output
if ((DEBUG > 1)); then
  set -o xtrace # show expanded commands
else
  set +o xtrace # do not show expanded commands
fi

IFS=$'\n\t'

unset CDPATH || true

# Override cd to suppress any output (stdout/stderr) to guard against environments
# that emit directory names (e.g., due to CDPATH or shell customization).
# Always use the builtin and exit on failure.
cd() {
	# Silent directory change. Let caller / set -e handle failures.
	builtin cd "$@" >/dev/null 2>&1 || return 1
}

#######################################
# Helper: print to stderr
#######################################
err() {
  # Check if stderr is a terminal and tput is available
  if [[ -t 2 ]] && command -v tput &>/dev/null; then
    local RED
    local RESET
    RED="$(tput setaf 1)"
    RESET="$(tput sgr0)"
    printf >&2 '[%sERROR%s] %s\n' "${RED}" "${RESET}" "$*"
  else
    printf >&2 '[ERROR] %s\n' "$*"
  fi
}

info() {
  # Check if stderr is a terminal and tput is available
  if [[ -t 2 ]] && command -v tput &>/dev/null; then
    local BLUE
    local RESET
    BLUE="$(tput setaf 4)"
    RESET="$(tput sgr0)"
    printf >&2 '[%sINFO%s] %s\n' "${BLUE}" "${RESET}" "$*"
  else
    printf >&2 '[INFO] %s\n' "$*"
  fi
}

warn() {
  # Check if stderr is a terminal and tput is available
  if [[ -t 2 ]] && command -v tput &>/dev/null; then
    local YELLOW
    local RESET
    YELLOW="$(tput setaf 3)"
    RESET="$(tput sgr0)"
    printf >&2 '[%sWARN%s] %s\n' "${YELLOW}" "${RESET}" "$*"
  else
    printf >&2 '[WARN] %s\n' "$*"
  fi
}

#######################################
# Usage
#######################################
usage() {
	cat >&2 <<'USAGE'
Usage: check-jspecify-dev.sh [options]

Options:
	--project-root <path>   Root directory of the multi-module Maven project (default: script parent dir/..)
	--clear-cache           Remove cached checker clone & artifacts before running
	-h, --help              Show this help and exit

Environment Overrides:
	JAVA_CMD   Path to javac (default: auto-detected in PATH)

Caching:
	Clone & build of jspecify-reference-checker is cached below:
	  ${XDG_CACHE_HOME:-$HOME/.cache}/coremedia-gcc/jspecify
	Use --clear-cache to force a fresh clone & rebuild.

The script will:
	1. Ensure required tools exist (javac, mvn, git if cloning needed, gradle only if wrapper absent).
	2. Verify javac reports version 17.*.
	3. Prepare (or reuse) cached clone & build jspecify-reference-checker if jar missing.
	4. Discover module roots containing src/main/java.
	5. For each module, build the compile classpath via Maven and run the NullSpecChecker.

Redirect output to capture a report:  check-jspecify-dev.sh > jspecify-report.txt
USAGE
}

#######################################
# Argument parsing
#######################################
PROJECT_ROOT=""
CLEAR_CACHE="false"

while [[ $# -gt 0 ]]; do
	case "$1" in
		--project-root)
				[[ $# -ge 2 ]] || { err "--project-root requires a value"; usage; exit 1; }
				PROJECT_ROOT="$2"; shift 2 ;;
			--clear-cache)
				CLEAR_CACHE="true"; shift ;;
		-h|--help)
			usage; exit 0 ;;
		*)
			err "Unknown argument: $1"; usage; exit 1 ;;
	esac
done

#######################################
# Resolve project root
#######################################
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -z "$PROJECT_ROOT" ]]; then
	PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
fi

if [[ ! -d "$PROJECT_ROOT" ]]; then
	err "Project root does not exist: $PROJECT_ROOT"; exit 1
fi

#######################################
# Dependency checks
#######################################
need() {
	command -v "$1" >/dev/null 2>&1 || { err "Required command '$1' not found in PATH"; exit 2; }
}

need mvn
need javac

JAVA_CMD=${JAVA_CMD:-javac}

#######################################
# Java version check (must be major version 17)
#######################################
JAVA_VERSION_RAW="$($JAVA_CMD -version 2>&1 | head -n1 || true)"
if [[ -z "$JAVA_VERSION_RAW" ]]; then
	err "Could not determine Java version (empty output from: $JAVA_CMD -version)"; exit 3
fi

# Extract first numeric version sequence, e.g. 17.0.15 from:
#   javac 17.0.15
#   openjdk version "17.0.15" 2024-10-15
#   javac 17
JAVA_VERSION_PARSED="$(grep -Eo '[0-9]+(\.[0-9]+)*' <<<"$JAVA_VERSION_RAW" | head -n1 || true)"
if [[ -z "$JAVA_VERSION_PARSED" ]]; then
	err "Unable to parse Java version from: $JAVA_VERSION_RAW"; exit 3
fi
JAVA_VERSION_MAJOR="${JAVA_VERSION_PARSED%%.*}"
if [[ "$JAVA_VERSION_MAJOR" != "17" ]]; then
	err "Java 17 required (found: $JAVA_VERSION_RAW)"; exit 3
fi
info "Detected Java $JAVA_VERSION_PARSED (raw: $JAVA_VERSION_RAW)"

#######################################
# Prepare (or reuse) cached checker clone
#######################################
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/coremedia-gcc/jspecify"
REPO_DIR="$CACHE_DIR/jspecify-reference-checker"

if [[ "$CLEAR_CACHE" == "true" ]]; then
	if [[ -d "$CACHE_DIR" ]]; then
		info "Clearing cache directory: $CACHE_DIR"
		rm -rf "$CACHE_DIR"
	fi
fi

mkdir -p "$CACHE_DIR"

if [[ ! -d "$REPO_DIR/.git" ]]; then
	info "Cloning jspecify-reference-checker into cache: $REPO_DIR"
	# Only require git if we actually need to clone.
	need git
	git clone --depth 1 https://github.com/jspecify/jspecify-reference-checker "$REPO_DIR" >/dev/null
else
	info "Reusing cached checker clone: $REPO_DIR"
fi

WORK_DIR="$REPO_DIR"

#######################################
# Build checker
#######################################
GRADLE_CONN_TIMEOUT_MS="${GRADLE_CONN_TIMEOUT_MS:-60000}"          # 60s connection timeout
GRADLE_SOCKET_TIMEOUT_MS="${GRADLE_SOCKET_TIMEOUT_MS:-180000}"    # 180s socket/read timeout
GRADLE_MAX_RETRIES="${GRADLE_MAX_RETRIES:-5}"                     # number of repository retry attempts
GRADLE_INITIAL_BACKOFF_MS="${GRADLE_INITIAL_BACKOFF_MS:-2000}"    # initial backoff 2s
GRADLE_BUILD_MAX_ATTEMPTS="${GRADLE_BUILD_MAX_ATTEMPTS:-3}"       # how many times to retry entire build

GRADLE_TIMEOUT_PROPS=(
	"-Dorg.gradle.internal.http.connectionTimeout=${GRADLE_CONN_TIMEOUT_MS}"
	"-Dorg.gradle.internal.http.socketTimeout=${GRADLE_SOCKET_TIMEOUT_MS}"
	"-Dorg.gradle.internal.repository.max.retries=${GRADLE_MAX_RETRIES}"
	"-Dorg.gradle.internal.repository.initial.backoff=${GRADLE_INITIAL_BACKOFF_MS}"
)

run_gradle_build() {
	local attempt=1
	while (( attempt <= GRADLE_BUILD_MAX_ATTEMPTS )); do
		info "Building checker (attempt ${attempt}/${GRADLE_BUILD_MAX_ATTEMPTS})"
		if [[ -f "$WORK_DIR/gradlew" ]]; then
			(cd "$WORK_DIR" && ./gradlew -q "${GRADLE_TIMEOUT_PROPS[@]}" assemble) && return 0
		else
			need gradle  # ensure global gradle exists only once we need it
			warn "gradlew not found; using system gradle (attempt ${attempt})"
			(cd "$WORK_DIR" && gradle -q "${GRADLE_TIMEOUT_PROPS[@]}" assemble) && return 0
		fi
		warn "Gradle build failed (attempt ${attempt})"
		attempt=$((attempt+1))
		sleep $(( attempt * 2 ))
	done
	return 1
}

JAR_PATH=""
# Concise probe for existing jar: cd failure is non-fatal due to function override + set -e rules with '&&'.
EXISTING_JAR="$(cd "$WORK_DIR/build/libs" 2>/dev/null && ls -1 jspecify-reference-checker-*.jar 2>/dev/null | head -n1 || true)"
if [[ -n "$EXISTING_JAR" ]]; then
	JAR_PATH="$WORK_DIR/build/libs/$EXISTING_JAR"
	info "Found existing checker jar (skip build): $JAR_PATH"
else
	if ! run_gradle_build; then
		err "Failed to build jspecify-reference-checker after ${GRADLE_BUILD_MAX_ATTEMPTS} attempts"
		exit 4
	fi
	NEW_JAR="$(cd "$WORK_DIR/build/libs" 2>/dev/null && ls -1 jspecify-reference-checker-*.jar 2>/dev/null | head -n1 || true)"
	if [[ -z "$NEW_JAR" ]]; then
		err "Could not locate built jspecify-reference-checker jar"; exit 4
	fi
	JAR_PATH="$WORK_DIR/build/libs/$NEW_JAR"
	info "Built checker JAR: $JAR_PATH"
fi

#######################################
# Attempt to locate Checker Framework distribution cloned by build
#######################################
CF_DIST_DIR=""
if [[ -d "$WORK_DIR/../checker-framework/checker/dist" ]]; then
	CF_DIST_DIR="$(cd "$WORK_DIR/../checker-framework/checker/dist" && pwd)"
	info "Detected Checker Framework dist: $CF_DIST_DIR"
elif [[ -d "$WORK_DIR/../checker-framework/dist" ]]; then
	CF_DIST_DIR="$(cd "$WORK_DIR/../checker-framework/dist" && pwd)"
	info "Detected Checker Framework dist (alt layout): $CF_DIST_DIR"
else
	warn "Checker Framework dist directory not found; BaseTypeChecker classes may be missing"
fi

# Build list of checker framework jars (if any)
CHECKER_FRAMEWORK_JARS=""
if [[ -n "$CF_DIST_DIR" ]]; then
	while IFS= read -r -d '' jar; do
		if [[ -z "$CHECKER_FRAMEWORK_JARS" ]]; then
			CHECKER_FRAMEWORK_JARS="$jar"
		else
			CHECKER_FRAMEWORK_JARS="$CHECKER_FRAMEWORK_JARS:$jar"
		fi
	done < <(find "$CF_DIST_DIR" -maxdepth 1 -type f -name '*.jar' -print0 | sort -z)
fi

if [[ -n "$CHECKER_FRAMEWORK_JARS" ]]; then
	info "Including Checker Framework jars ($(tr ':' '\n' <<<"$CHECKER_FRAMEWORK_JARS" | wc -l | tr -d ' ')) on processor/classpath"
fi

#######################################
# Required JDK module exports/opens for Checker Framework on JDK >= 9
# (Derived from Checker Framework manual; without these, IllegalAccessError occurs.)
#######################################
JDK_EXPORT_OPEN_FLAGS=(
	-J--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
	-J--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED
)
info "Applying ${#JDK_EXPORT_OPEN_FLAGS[@]} JDK export/open flags (via -J) for Checker Framework"

#######################################
# Discover module roots with src/main/java
#######################################
mapfile -t MODULE_SOURCE_DIRS < <(find "$PROJECT_ROOT" -type d -path '*/src/main/java')
if [[ ${#MODULE_SOURCE_DIRS[@]} -eq 0 ]]; then
	err "No Java source roots found under $PROJECT_ROOT"; exit 5
fi

#######################################
# Process each module
#######################################
EXIT_STATUS=0
TOTAL=${#MODULE_SOURCE_DIRS[@]}
INDEX=0

for src_dir in "${MODULE_SOURCE_DIRS[@]}"; do
	INDEX=$((INDEX+1))
	module_dir="${src_dir%/src/main/java}"
	rel_module_dir="${module_dir#$PROJECT_ROOT/}"
	printf '\n===== (%d/%d) Module: %s =====\n' "$INDEX" "$TOTAL" "$rel_module_dir"

	if [[ ! -f "$module_dir/pom.xml" ]]; then
		warn "Skipping (no pom.xml): $rel_module_dir"
		continue
	fi

	tmp_cp_file="$(mktemp -t jspecify-cp-XXXXXX)"
	# Build classpath quietly
	if ! (cd "$module_dir" && mvn -q dependency:build-classpath -Dmdep.outputFile="$tmp_cp_file" -Dmdep.includeScope=compile >/dev/null); then
		err "Maven classpath build failed for $rel_module_dir"
		EXIT_STATUS=1
		rm -f "$tmp_cp_file"
		continue
	fi
	module_cp="$(cat "$tmp_cp_file")" || true
	rm -f "$tmp_cp_file"

	# Collect Java sources
	mapfile -t JAVA_FILES < <(find "$src_dir" -type f -name '*.java')
	if [[ ${#JAVA_FILES[@]} -eq 0 ]]; then
		warn "No Java files: $rel_module_dir"
		continue
	fi

	# Run checker (do not abort entire script on single module failure)
		# Compose processorpath and classpath
		processor_path_components=("$JAR_PATH")
		class_path_components=("$JAR_PATH" "$module_cp")
		if [[ -n "$CHECKER_FRAMEWORK_JARS" ]]; then
			processor_path_components+=("$CHECKER_FRAMEWORK_JARS")
			class_path_components+=("$CHECKER_FRAMEWORK_JARS")
		fi
		PROCESSOR_PATH_JOINED="$(IFS=:; echo "${processor_path_components[*]}")"
		CLASS_PATH_JOINED="$(IFS=:; echo "${class_path_components[*]}")"

		  if ! "$JAVA_CMD" \
			  "${JDK_EXPORT_OPEN_FLAGS[@]}" \
				-encoding UTF-8 \
				-processorpath "$PROCESSOR_PATH_JOINED" \
				-classpath "$CLASS_PATH_JOINED" \
			-processor com.google.jspecify.nullness.NullSpecChecker \
			-AcheckImpl -AassumePure \
			-AsuppressWarnings=contracts.conditional.postcondition.false.methodref,contracts.conditional.postcondition.false.override,contracts.conditional.postcondition.true.methodref,contracts.conditional.postcondition.true.override,purity.methodref,purity.overriding,type.anno.before.decl.anno,type.anno.before.modifier \
			"${JAVA_FILES[@]}"; then
		warn "Checker failed for module: $rel_module_dir"
		EXIT_STATUS=1
	fi
done

printf '\nAll modules processed. Exit status: %d\n' "$EXIT_STATUS"
exit "$EXIT_STATUS"
