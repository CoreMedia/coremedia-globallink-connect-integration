#!/usr/bin/env bash

# Purpose:
#   Run the experimental JSpecify reference checker (NullSpecChecker) over all
#   Maven modules in this repository that contain a src/main/java tree.
#
# Notes:
#   * The jspecify-reference-checker is a proof-of-concept and must be built locally.
#   * This script clones the checker into a temporary directory (unless an existing
#     directory is provided) and cleans it up afterwards.
#   * Only Java 17 is supported by the checker at the moment; the script enforces that.
#   * Output is streamed to stdout; redirect if you want to capture a report.
#
# Usage:
#   bin/check-jspecify-dev.sh [--project-root <path>] [--keep-temp] [--checker-dir <existing-clone>]
#
# Examples:
#   bin/check-jspecify-dev.sh > jspecify-report.txt
#   bin/check-jspecify-dev.sh --project-root /path/to/checkout --keep-temp
#   bin/check-jspecify-dev.sh --checker-dir /tmp/existing-jspecify-clone
#
# Exit Codes:
#   0 - All modules processed (individual checker warnings may still appear)
#   1 - Usage / argument error
#   2 - Missing dependency
#   3 - Java version unsupported
#   4 - Build failure of jspecify-reference-checker
#   5 - No Java source modules found
#
# Script initially generated by GitHub Copilot (GPT-5).

set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'

unset CDPATH || true

# Override cd to suppress any output (stdout/stderr) to guard against environments
# that emit directory names (e.g., due to CDPATH or shell customization).
# Always use the builtin and exit on failure.
cd() {
	builtin cd "$@" >/dev/null 2>&1 || { err "Failed to change directory to: $*"; exit 1; }
}

#######################################
# Helper: print to stderr
#######################################
err() {
  # Check if stderr is a terminal and tput is available
  if [[ -t 2 ]] && command -v tput &>/dev/null; then
    local RED
    local RESET
    RED="$(tput setaf 1)"
    RESET="$(tput sgr0)"
    printf >&2 '[%sERROR%s] %s\n' "${RED}" "${RESET}" "$*"
  else
    printf >&2 '[ERROR] %s\n' "$*"
  fi
}

info() { printf >&2 '[INFO] %s\n' "$*"; }

warn() {
  # Check if stderr is a terminal and tput is available
  if [[ -t 2 ]] && command -v tput &>/dev/null; then
    local YELLOW
    local RESET
    YELLOW="$(tput setaf 3)"
    RESET="$(tput sgr0)"
    printf >&2 '[%sWARN%s] %s\n' "${YELLOW}" "${RESET}" "$*"
  else
    printf >&2 '[WARN] %s\n' "$*"
  fi
}

#######################################
# Usage
#######################################
usage() {
	cat >&2 <<'USAGE'
Usage: check-jspecify-dev.sh [options]

Options:
	--project-root <path>   Root directory of the multi-module Maven project (default: script parent dir/..)
	--checker-dir  <path>   Reuse existing clone of jspecify-reference-checker (skip cloning)
	--keep-temp             Do not delete the temporary working directory
	-h, --help              Show this help and exit

Environment Overrides:
	JAVA_CMD   Path to javac (default: auto-detected in PATH)

The script will:
	1. Ensure required tools exist (git, javac, mvn, gradlew wrapper in clone).
	2. Verify javac reports version 17.*.
	3. Clone & build jspecify-reference-checker (unless --checker-dir provided).
	4. Discover module roots containing src/main/java.
	5. For each module, build the compile classpath via Maven and run the NullSpecChecker.

Redirect output to capture a report:  check-jspecify-dev.sh > jspecify-report.txt
USAGE
}

#######################################
# Argument parsing
#######################################
PROJECT_ROOT=""
CHECKER_DIR=""
KEEP_TEMP="false"

while [[ $# -gt 0 ]]; do
	case "$1" in
		--project-root)
			[[ $# -ge 2 ]] || { err "--project-root requires a value"; usage; exit 1; }
			PROJECT_ROOT="$2"; shift 2 ;;
		--checker-dir)
			[[ $# -ge 2 ]] || { err "--checker-dir requires a value"; usage; exit 1; }
			CHECKER_DIR="$2"; shift 2 ;;
		--keep-temp)
			KEEP_TEMP="true"; shift ;;
		-h|--help)
			usage; exit 0 ;;
		*)
			err "Unknown argument: $1"; usage; exit 1 ;;
	esac
done

#######################################
# Resolve project root
#######################################
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -z "$PROJECT_ROOT" ]]; then
	PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
fi

if [[ ! -d "$PROJECT_ROOT" ]]; then
	err "Project root does not exist: $PROJECT_ROOT"; exit 1
fi

#######################################
# Dependency checks
#######################################
need() {
	command -v "$1" >/dev/null 2>&1 || { err "Required command '$1' not found in PATH"; exit 2; }
}

need git
need mvn
need javac

JAVA_CMD=${JAVA_CMD:-javac}

#######################################
# Java version check (must be major version 17)
#######################################
JAVA_VERSION_RAW="$($JAVA_CMD -version 2>&1 | head -n1 || true)"
if [[ -z "$JAVA_VERSION_RAW" ]]; then
	err "Could not determine Java version (empty output from: $JAVA_CMD -version)"; exit 3
fi

# Extract first numeric version sequence, e.g. 17.0.15 from:
#   javac 17.0.15
#   openjdk version "17.0.15" 2024-10-15
#   javac 17
JAVA_VERSION_PARSED="$(grep -Eo '[0-9]+(\.[0-9]+)*' <<<"$JAVA_VERSION_RAW" | head -n1 || true)"
if [[ -z "$JAVA_VERSION_PARSED" ]]; then
	err "Unable to parse Java version from: $JAVA_VERSION_RAW"; exit 3
fi
JAVA_VERSION_MAJOR="${JAVA_VERSION_PARSED%%.*}"
if [[ "$JAVA_VERSION_MAJOR" != "17" ]]; then
	err "Java 17 required (found: $JAVA_VERSION_RAW)"; exit 3
fi
info "Detected Java $JAVA_VERSION_PARSED (raw: $JAVA_VERSION_RAW)"

#######################################
# Prepare working directory for checker clone
#######################################
TEMP_DIR=""
if [[ -n "$CHECKER_DIR" ]]; then
	if [[ ! -d "$CHECKER_DIR" ]]; then
		err "Provided --checker-dir does not exist: $CHECKER_DIR"; exit 1
	fi
	WORK_DIR="$CHECKER_DIR"
	info "Using existing checker clone: $WORK_DIR"
else
	TEMP_DIR="$(mktemp -d -t jspecify-XXXXXX)"
	WORK_DIR="$TEMP_DIR/jspecify-reference-checker"
	info "Cloning jspecify-reference-checker into $WORK_DIR"
	git clone --depth 1 https://github.com/jspecify/jspecify-reference-checker "$WORK_DIR" >/dev/null
fi

cleanup() {
	if [[ "$KEEP_TEMP" != "true" && -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
		rm -rf "$TEMP_DIR"
	else
		[[ -n "$TEMP_DIR" ]] && info "Temp directory retained: $TEMP_DIR"
	fi
}
trap cleanup EXIT

#######################################
# Build checker
#######################################
GRADLE_CONN_TIMEOUT_MS="${GRADLE_CONN_TIMEOUT_MS:-60000}"          # 60s connection timeout
GRADLE_SOCKET_TIMEOUT_MS="${GRADLE_SOCKET_TIMEOUT_MS:-180000}"    # 180s socket/read timeout
GRADLE_MAX_RETRIES="${GRADLE_MAX_RETRIES:-5}"                     # number of repository retry attempts
GRADLE_INITIAL_BACKOFF_MS="${GRADLE_INITIAL_BACKOFF_MS:-2000}"    # initial backoff 2s
GRADLE_BUILD_MAX_ATTEMPTS="${GRADLE_BUILD_MAX_ATTEMPTS:-3}"       # how many times to retry entire build

GRADLE_TIMEOUT_PROPS=(
	"-Dorg.gradle.internal.http.connectionTimeout=${GRADLE_CONN_TIMEOUT_MS}"
	"-Dorg.gradle.internal.http.socketTimeout=${GRADLE_SOCKET_TIMEOUT_MS}"
	"-Dorg.gradle.internal.repository.max.retries=${GRADLE_MAX_RETRIES}"
	"-Dorg.gradle.internal.repository.initial.backoff=${GRADLE_INITIAL_BACKOFF_MS}"
)

run_gradle_build() {
	local attempt=1
	while (( attempt <= GRADLE_BUILD_MAX_ATTEMPTS )); do
		info "Building checker (attempt ${attempt}/${GRADLE_BUILD_MAX_ATTEMPTS})"
		if [[ -f "$WORK_DIR/gradlew" ]]; then
			(cd "$WORK_DIR" && ./gradlew -q "${GRADLE_TIMEOUT_PROPS[@]}" assemble) && return 0
		else
			need gradle  # ensure global gradle exists only once we need it
			warn "gradlew not found; using system gradle (attempt ${attempt})"
			(cd "$WORK_DIR" && gradle -q "${GRADLE_TIMEOUT_PROPS[@]}" assemble) && return 0
		fi
		warn "Gradle build failed (attempt ${attempt})"
		attempt=$((attempt+1))
		sleep $(( attempt * 2 ))
	done
	return 1
}

if ! run_gradle_build; then
	err "Failed to build jspecify-reference-checker after ${GRADLE_BUILD_MAX_ATTEMPTS} attempts"
	exit 4
fi

JAR_PATH="$(cd "$WORK_DIR/build/libs" && ls -1 jspecify-reference-checker-*.jar 2>/dev/null | head -n1 || true)"
if [[ -z "$JAR_PATH" ]]; then
	err "Could not locate built jspecify-reference-checker jar"; exit 4
fi
JAR_PATH="$WORK_DIR/build/libs/$JAR_PATH"
info "Checker JAR: $JAR_PATH"

#######################################
# Attempt to locate Checker Framework distribution cloned by build
#######################################
CF_DIST_DIR=""
if [[ -d "$WORK_DIR/../checker-framework/checker/dist" ]]; then
	CF_DIST_DIR="$(cd "$WORK_DIR/../checker-framework/checker/dist" && pwd)"
	info "Detected Checker Framework dist: $CF_DIST_DIR"
elif [[ -d "$WORK_DIR/../checker-framework/dist" ]]; then
	CF_DIST_DIR="$(cd "$WORK_DIR/../checker-framework/dist" && pwd)"
	info "Detected Checker Framework dist (alt layout): $CF_DIST_DIR"
else
	warn "Checker Framework dist directory not found; BaseTypeChecker classes may be missing"
fi

# Build list of checker framework jars (if any)
CHECKER_FRAMEWORK_JARS=""
if [[ -n "$CF_DIST_DIR" ]]; then
	while IFS= read -r -d '' jar; do
		if [[ -z "$CHECKER_FRAMEWORK_JARS" ]]; then
			CHECKER_FRAMEWORK_JARS="$jar"
		else
			CHECKER_FRAMEWORK_JARS="$CHECKER_FRAMEWORK_JARS:$jar"
		fi
	done < <(find "$CF_DIST_DIR" -maxdepth 1 -type f -name '*.jar' -print0 | sort -z)
fi

if [[ -n "$CHECKER_FRAMEWORK_JARS" ]]; then
	info "Including Checker Framework jars ($(tr ':' '\n' <<<"$CHECKER_FRAMEWORK_JARS" | wc -l | tr -d ' ')) on processor/classpath"
fi

#######################################
# Required JDK module exports/opens for Checker Framework on JDK >= 9
# (Derived from Checker Framework manual; without these, IllegalAccessError occurs.)
#######################################
JDK_EXPORT_OPEN_FLAGS=(
	-J--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED
	-J--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
	-J--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED
)
info "Applying ${#JDK_EXPORT_OPEN_FLAGS[@]} JDK export/open flags (via -J) for Checker Framework"

#######################################
# Discover module roots with src/main/java
#######################################
mapfile -t MODULE_SOURCE_DIRS < <(find "$PROJECT_ROOT" -type d -path '*/src/main/java')
if [[ ${#MODULE_SOURCE_DIRS[@]} -eq 0 ]]; then
	err "No Java source roots found under $PROJECT_ROOT"; exit 5
fi

#######################################
# Process each module
#######################################
EXIT_STATUS=0
TOTAL=${#MODULE_SOURCE_DIRS[@]}
INDEX=0

for src_dir in "${MODULE_SOURCE_DIRS[@]}"; do
	INDEX=$((INDEX+1))
	module_dir="${src_dir%/src/main/java}"
	rel_module_dir="${module_dir#$PROJECT_ROOT/}"
	printf '\n===== (%d/%d) Module: %s =====\n' "$INDEX" "$TOTAL" "$rel_module_dir"

	if [[ ! -f "$module_dir/pom.xml" ]]; then
		warn "Skipping (no pom.xml): $rel_module_dir"
		continue
	fi

	tmp_cp_file="$(mktemp -t jspecify-cp-XXXXXX)"
	# Build classpath quietly
	if ! (cd "$module_dir" && mvn -q dependency:build-classpath -Dmdep.outputFile="$tmp_cp_file" -Dmdep.includeScope=compile >/dev/null); then
		err "Maven classpath build failed for $rel_module_dir"
		EXIT_STATUS=1
		rm -f "$tmp_cp_file"
		continue
	fi
	module_cp="$(cat "$tmp_cp_file")" || true
	rm -f "$tmp_cp_file"

	# Collect Java sources
	mapfile -t JAVA_FILES < <(find "$src_dir" -type f -name '*.java')
	if [[ ${#JAVA_FILES[@]} -eq 0 ]]; then
		warn "No Java files: $rel_module_dir"
		continue
	fi

	# Run checker (do not abort entire script on single module failure)
		# Compose processorpath and classpath
		processor_path_components=("$JAR_PATH")
		class_path_components=("$JAR_PATH" "$module_cp")
		if [[ -n "$CHECKER_FRAMEWORK_JARS" ]]; then
			processor_path_components+=("$CHECKER_FRAMEWORK_JARS")
			class_path_components+=("$CHECKER_FRAMEWORK_JARS")
		fi
		PROCESSOR_PATH_JOINED="$(IFS=:; echo "${processor_path_components[*]}")"
		CLASS_PATH_JOINED="$(IFS=:; echo "${class_path_components[*]}")"

		  if ! "$JAVA_CMD" \
			  "${JDK_EXPORT_OPEN_FLAGS[@]}" \
				-encoding UTF-8 \
				-processorpath "$PROCESSOR_PATH_JOINED" \
				-classpath "$CLASS_PATH_JOINED" \
			-processor com.google.jspecify.nullness.NullSpecChecker \
			-AcheckImpl -AassumePure \
			-AsuppressWarnings=contracts.conditional.postcondition.false.methodref,contracts.conditional.postcondition.false.override,contracts.conditional.postcondition.true.methodref,contracts.conditional.postcondition.true.override,purity.methodref,purity.overriding,type.anno.before.decl.anno,type.anno.before.modifier \
			"${JAVA_FILES[@]}"; then
		warn "Checker failed for module: $rel_module_dir"
		EXIT_STATUS=1
	fi
done

printf '\nAll modules processed. Exit status: %d\n' "$EXIT_STATUS"
exit "$EXIT_STATUS"
