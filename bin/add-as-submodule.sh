#!/usr/bin/env bash
#
# Add the CoreMedia GlobalLink Connect Integration repository as a git submodule.
#
# Usage:
#   bin/add-as-submodule.sh <target-path> [<branch-or-tag>]
#
# Examples:
#   bin/add-as-submodule.sh modules/extensions/gcc
#   bin/add-as-submodule.sh blueprint/modules/extensions/gcc maintenance/2506.x
#   bin/add-as-submodule.sh modules/extensions/gcc v2506.0.1-1
#
# Env:
#   GLOBALLINK_REPO_URL  Override default repository URL.
#
# Notes:
#   - Creates all missing parent directories.
#   - Branch ref => tracking; tag ref => detached at tag.
#   - All cd output suppressed (CDPATH safe).
#
# Script initially generated by GitHub Copilot (GPT-5).

set -o errexit
set -o nounset
set -o pipefail

unset CDPATH || true

readonly SCRIPT_NAME="$(basename "$0")"
readonly DEFAULT_REF="maintenance/2506.x"
readonly REPO_URL_DEFAULT="https://github.com/CoreMedia/coremedia-globallink-connect-integration.git"
readonly REPO_URL="${GLOBALLINK_REPO_URL:-$REPO_URL_DEFAULT}"
readonly SUBMODULE_NAME="coremedia-globallink-connect-integration"

usage() {
  printf 'Usage: %s <target-path> [<branch-or-tag>]\n' "${SCRIPT_NAME}"
  printf 'Adds the %s repository as a git submodule at the given path.\n' "${SUBMODULE_NAME}"
  printf 'Defaults to ref: %s\n' "${DEFAULT_REF}"
}

error() {
  printf 'Error: %s\n' "$1" >&2
  exit 1
}

info() {
  printf '%s\n' "$1"
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || error "Required command '$1' not found."
}

normalize_relative() {
  # Input: relative path (may contain . or ..)
  local raw=$1
  local -a parts stack
  IFS='/' read -r -a parts <<< "${raw}"
  local p
  for p in "${parts[@]}"; do
    case "${p}" in
      ''|'.') continue ;;
      '..')
        if [[ ${#stack[@]} -gt 0 ]]; then
          unset 'stack[${#stack[@]}-1]'
        else
          error "Path attempts to escape repository root via '..'."
        fi
        ;;
      *)
        stack+=("${p}")
        ;;
    esac
  done
  local normalized
  if [[ ${#stack[@]} -eq 0 ]]; then
    normalized=""
  else
    (IFS=/; printf '%s' "${stack[*]}")
  fi
}

detect_ref_type() {
  local ref=$1
  if git ls-remote --exit-code --heads "${REPO_URL}" "${ref}" >/dev/null 2>&1; then
    printf 'branch\n'
    return 0
  fi
  if git ls-remote --exit-code --tags "${REPO_URL}" "refs/tags/${ref}" >/dev/null 2>&1; then
    printf 'tag\n'
    return 0
  fi
  error "Ref '${ref}' not found (neither branch nor tag)."
}

add_branch_submodule() {
  local rel_target=$1
  local ref=$2
  info "Adding submodule tracking branch '${ref}'."
  git submodule add -b "${ref}" "${REPO_URL}" "${rel_target}"
}

add_tag_submodule() {
  local rel_target=$1
  local ref=$2
  info "Adding submodule at tag '${ref}'."
  git submodule add "${REPO_URL}" "${rel_target}"
  (
    cd "${rel_target}" >/dev/null 2>&1
    git fetch --tags --quiet
    if ! git checkout "refs/tags/${ref}" >/dev/null 2>&1; then
      git checkout "${ref}" >/dev/null 2>&1 || error "Failed to checkout tag '${ref}'."
    fi
  )
}

main() {
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    usage
    exit 1
  fi

  require_cmd git

  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    error "Not inside a git repository."
  fi

  local target_input=$1
  local ref=${2:-${DEFAULT_REF}}

  [[ -z "${target_input}" ]] && error "Target path must not be empty."

  local repo_root
  repo_root=$(git rev-parse --show-toplevel)

  # Strip trailing slashes
  target_input=${target_input%/}

  local rel_candidate
  if [[ "${target_input}" = /* ]]; then
    case "${target_input}" in
      "${repo_root}") rel_candidate="" ;;
      "${repo_root}"/*) rel_candidate=${target_input#${repo_root}/} ;;
      *) error "Absolute target outside repository root." ;;
    esac
  else
    rel_candidate=${target_input}
  fi

  local rel_normalized
  rel_normalized=$(normalize_relative "${rel_candidate}")

  [[ -z "${rel_normalized}" ]] && error "Refusing to place submodule at repository root."

  local abs_target="${repo_root}/${rel_normalized}"

  # Create parent directories if missing
  local parent_dir
  parent_dir=$(dirname -- "${abs_target}")
  if [[ ! -d "${parent_dir}" ]]; then
    info "Creating parent directories: ${parent_dir#${repo_root}/}"
    mkdir -p -- "${parent_dir}"
  fi

  # Validate existing target (must be absent or empty directory)
  if [[ -e "${abs_target}" ]]; then
    if [[ -d "${abs_target}" ]]; then
      if [[ -n "$(ls -A "${abs_target}" 2>/dev/null || true)" ]]; then
        error "Target directory '${rel_normalized}' exists and is not empty."
      fi
    else
      error "Path '${rel_normalized}' exists and is not a directory."
    fi
  fi

  info "Repository URL : ${REPO_URL}"
  info "Target path    : ${rel_normalized}"
  info "Requested ref  : ${ref}"

  local ref_type
  ref_type=$(detect_ref_type "${ref}")

  if [[ "${ref_type}" == "branch" ]]; then
    add_branch_submodule "${rel_normalized}" "${ref}"
  else
    add_tag_submodule "${rel_normalized}" "${ref}"
  fi

  git add .gitmodules "${rel_normalized}"
  git commit -m "Add submodule ${SUBMODULE_NAME} at '${rel_normalized}' (ref: ${ref})"

  info "Submodule added and committed."
  info "Next steps:"
  if [[ "${ref_type}" == "branch" ]]; then
    printf '  - Update later: git submodule update --remote --merge %s\n' "${rel_normalized}"
  else
    printf '  - Move to newer tag: (cd %s && git fetch --tags && git checkout <tag>); git add %s; git commit -m "Bump %s"\n' "${rel_normalized}" "${rel_normalized}" "${SUBMODULE_NAME}"
  fi
  printf '  - After fresh clone: git submodule update --init --recursive\n'
}

main "$@"
